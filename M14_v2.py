# -*- coding: utf-8 -*-
"""Profissao Cientista de Dados M14 Pratique.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gCmZuFP6UoYECPJsrShLoe3MX-BEVmwg

# **MÓDULO 14 - Exercício**

O que é churn?

Churn (ou taxa de rotatividade) é a porcentagem de clientes que deixam de usar um produto ou serviço num determinado período.
Fórmula:
Churn Rate (%)=Clientes perdidosClientes no inıˊcio do perıˊodo×100
Churn Rate (%)=Clientes no inıˊcio do perıˊodoClientes perdidos​×100




# Pré Processamento dos Dados - A primeira etapa Pré Modelagem

Para nossa atividade usaremos uma base de churn também, porém essa base não diz respeito a serviços bancários e sim serviços de internet, telefone e tv - Telecomunicação.

Vamos realizar aqui as etapas de limpeza e tratamento de dados vistos durante a aula, porém aplicados a essa base nova.
"""

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from IPython.display import display # Função para melhorar a exibição de DataFrames no Colab/Jupyter

#ETAPA -COLETA
df = pd.read_csv("CHURN_TELECON_MOD08_TAREFA.csv", delimiter=';')
df.head(-5)

"""Legenda dos dados:

*   **CustomerID** : Esse é o ID único de cada cliente nosso da rede de produtos de telecomunicação.

*   **Genero** : O genero dos nossos clientes.

*   **Idoso** : Se nosso cliente tem acima de 60 anos ou não. (Sim = 1 | Não = 0)

*   **Casado** : Se nosso cliente é casado ou não.

*   **Dependents** : Se cliente tem dependentes.

*   **Tempo_como_Cliente** : Tempo em meses que nosso cliente está com a nossa empresa.

*   **PhoneService** : Se ele contratou serviço telefônico com a nossa empresa.

*   **Servico_Internet** : Qual o tipo de serviço de internet contratado.

*   **Servico_Seguranca** : Se ele contratou serviço de segurança com a nossa empresa.

*   **Suporte_Tecnico** : Se já acionou o suporte técnico.

*   **StreamingTV** : Se ele contratou serviço de streaming para TV.

*   **Tipo_Contrato** : Qual o tipo de contrato dos nossos clientes, se era mensal, anual etc.

*   **Tipo_Contrato** : Qual o tipo de contrato dos nossos clientes, se era mensal, anual etc.

*   **PaymentMethod** : Forma de Pagamento.

*   **Pagamento_Mensal** : Quanto o cliente pagava mensalmente.

*   **Total_Pago** : Total já pago pelo cliente para nossa companhia.

*   **Churn** : Nossa coluna mais importante, se nosso cliente nos abandonou ou não.

# 1 - Carregue a base, verifique se os tipos de dados estão de acordo com cada coluna e caso não estejam realize a transformação dos tipos de dados.
"""

#ETAPA DE VALIDAÇÃO - Informações iniciais tipologia do DataFrame - Classes
print(df.info())

#ETAPA DE VALIDAÇÃO  - Verificar Nome das Colunas
print(df.columns.tolist())

#ETAPA DE VALIDAÇÃO - Informações iniciais do DataFrame - Visualização DataFrame (Primeiras e últimas 5 linhas)

df.head(-5)

"""# 2 - Esse exercício faremos por etapas:
A) Verifique se temos colunas com dados faltantes e traga a % dos dados faltantes por coluna.
"""

#ETAPA DE VALIDAÇÃO - Verificar Zero e NAN

#Número total de linhas do DataFrame
total_rows = len(df)
print(total_rows)

#ETAPA DE VALIDAÇÃO - Verificar Zero e NAN

#Verificar valores ausentes (NaN)
check_values = df.isna().sum()
values_percent = (check_values / total_rows * 100).round(2)

print("\nValores ausentes (quantidade e %):\n")
display(pd.DataFrame({'Total': check_values, '%': values_percent}))

#ETAPA DE VALIDAÇÃO - Valores zero nas colunas numéricas

numeric_cols = df.select_dtypes(include=['number']).columns
zero_counts = (df[numeric_cols] == 0).sum()
zero_percent = (zero_counts / total_rows * 100).round(2)

#SAÍDA
print(numeric_cols)

#SAÍDA
print(zero_counts)

#SAÍDA
print(zero_percent)

#SAÍDA - Valores Zero
print("\n Valores Zero:\n ")
print(pd.DataFrame({'Total': zero_counts, '%': zero_percent}))

#SAÍDA - Isolamento 'Tempo _omo_ Cliente'
print(f"\n Registros com Tempo_como_Cliente == 0: {len(clientes_tempo_zero)}\n ")

#Exibir somente colunas relevantes com uso da biblioteca 'display'
colunas_relevantes = ['customerID', 'Tempo_como_Cliente', 'Genero', 'Pagamento_Mensal', 'Total_Pago', 'Churn']
display(clientes_tempo_zero[colunas_relevantes].reset_index(drop=True))

#ETAPA DE VALIDAÇÃO - Verificar Zero e NAN

#Verificar valores (0) zero nas colunas numéricas (exceto 'Idoso', onde zero é válido)
numeric_cols = df.select_dtypes(include=['number']).columns
zero_counts = (df[numeric_cols] == 0).sum()

#Calcular percentuais
values_percent = (check_values / total_rows * 100).round(2)
zero_percent = (zero_counts / total_rows * 100).round(2)

#SAÍDA
print("\n Valores ausentes (quantidade e %):\n ")
display(pd.DataFrame({'Total': check_values, '%': values_percent}))

"""#B) Exclua nessa etapa as linhas das colunas com dados faltantes que você analisar que esse método é o ideal. Justifique o motivo de estar excluindo essas linhas.

#Resposta
Podem prejudicar as análises e gerações de gráficos com os valores corretos.
"""

#VERIFICAÇÃO - SAÍDA
print("\n Valores zero nas colunas numéricas (quantidade e %):\n ")
display(pd.DataFrame({'Total': zero_counts, '%': zero_percent}))

#ETAPA DE VALIDAÇÃO - Excluir Linhas: Zero e NAN (exceto coluna 'Idoso')

#Remover linhas com qualquer valor ausente (NaN):
df_clean = df.dropna()

#Remover linhas com valor (0) zero de colunas identificadas:
colunas_com_zero_invalido = ['Tempo_como_Cliente']
for col in colunas_com_zero_invalido:
    df_clean = df_clean[df_clean[col] != 0]

# SAÍDA
print(f"\n Linhas restantes após isolamento : \n {len(df_clean)} \n ")
display(df_clean.head())

"""#C) Nessa etapa substitua pela média, mediana ou moda as linhas das colunas com valores faltantes que você analisou e entendeu que esse era o melhor método. Não se esqueça de justificar sua escolha.

**Dica variáveis numéricas:** Não se esqueça de verificar a distrbuição dos dados, média e mediana.

**Dica variáveis categóricas:** Caso precise substituir uma variável categórica utilize um gráfico de barras para verificar a que mais aparece e utilizar ela na substituição.
Ou você pode optar por excluir a coluna, mas justifique sua escolha.

Caso opte por substituir você pode utilizar a função fillna:
df['SUACOLUNA'].fillna("VALOR QUE SUBSTITUIRA O NULO", inplace=True)
Ela funcionará como a replace.

#Resposta:

1- Apliquei a **mediana** porque a distribuição estava assimétrica (havia valores muito altos e/ou baixos).

2- Apliquei a **moda** porque é uma variável categórica e esse era o valor mais comum.

3- Apliquei a **média** porque a distribuição era equilibrada e sem outliers.
"""

#ISOLAMENTO - Identificar colunas com valores faltantes

print("\nColunas com valores faltantes:")
print(df.isna().sum()[df.isna().sum() > 0])

#ISOLAMENTO - Isolar as colunas com valores faltantes

faltantes_colunas = df.columns[df.isna().any()]
print("\n Colunas identificadas:", faltantes_colunas.tolist())

#ISOLAMENTO - Verificar 'class' colunas com valores faltantes
print("\n Tipos das colunas faltantes:")
print(df[faltantes_colunas].dtypes)

#ESTATÍSTICA - Média, Moda e Mediana

#Categóricas - moda
moda_genero = df['Genero'].mode()[0]
moda_phoneservice = df['PhoneService'].mode()[0]
moda_churn = df['Churn'].mode()[0]

# Numérica - média e mediana
media_pagamento = df['Pagamento_Mensal'].mean()
mediana_pagamento = df['Pagamento_Mensal'].median()

# Exibir decisão
print("\nEstatísticas para análise:")
print(f"Moda - Genero: {moda_genero}")
print(f"Moda - PhoneService: {moda_phoneservice}")
print(f"Moda - Churn: {moda_churn}")
print(f"Pagamento_Mensal - Média: R$ {media_pagamento:.2f} | Mediana: R$ {mediana_pagamento:.2f}")

#Substituir os valores ausentes

df['Genero'] = df['Genero'].fillna(moda_genero)
df['PhoneService'] = df['PhoneService'].fillna(moda_phoneservice)
df['Churn'] = df['Churn'].fillna(moda_churn)
df['Pagamento_Mensal'] = df['Pagamento_Mensal'].fillna(mediana_pagamento)

print(df.isna().sum())

#ESTATÍSTICA

#Ver moda das variáveis categóricas
moda_genero = df['Genero'].mode()[0]
moda_phoneservice = df['PhoneService'].mode()[0]
moda_churn = df['Churn'].mode()[0]

#Ver média e mediana da variável numérica
media_pagamento = df['Pagamento_Mensal'].mean()
mediana_pagamento = df['Pagamento_Mensal'].median()

print(f"Moda Genero: {moda_genero}")
print(f"Moda PhoneService: {moda_phoneservice}")
print(f"Moda Churn: {moda_churn}")
print(f"Média Pagamento_Mensal: {media_pagamento:.2f}")
print(f"Mediana Pagamento_Mensal: {mediana_pagamento:.2f}")

"""# 3 - Verifique se encontramos valores digitados incorretamente, ou com letras maiusculas ou minusculas, ou até mesmo mesmos valores porém escritos de forma dirente e corrija."""

#DEPURAÇÃO - Corrigir valores inconsistentes nos dados categóricos

# Corrigir 'Genero': padronizar F/M/f para Female/Male
df['Genero'] = df['Genero'].replace({
    'F': 'Female',
    'f': 'Female',
    'M': 'Male'
})

# Corrigir 'Servico_Internet': padronizar 'dsl' para 'DSL'
df['Servico_Internet'] = df['Servico_Internet'].replace({
    'dsl': 'DSL'
})

# Verificar colunas com possíveis categorias como 'No internet service'
cols_to_check = ['Servico_Seguranca', 'Suporte_Tecnico', 'StreamingTV']
for col in cols_to_check:
    df[col] = df[col].replace({'No internet service': 'No'})

# Conferir os valores únicos após as correções
corrected_values = {col: df[col].unique() for col in df.select_dtypes(include='object').columns}

# Verificar os valores únicos por coluna categórica após as correções
colunas_categoricas = df.select_dtypes(include='object').columns

print(colunas_categoricas)

#IDENTIFICAÇÃO

# Listar todos os valores únicos por coluna categórica (corrigidas):
colunas_categoricas = df.select_dtypes(include='object').columns

# Dicionário para armazenar os valores únicos corrigidos por coluna:
valores_corrigidos = {col: sorted(df[col].dropna().unique()) for col in colunas_categoricas}

# Verificar valores únicos corrigidos por coluna categórica:
colunas_categoricas = df.select_dtypes(include='object').columns

for col in colunas_categoricas:
    print(f"{col}: {sorted(df[col].dropna().unique())}")

sns.countplot(data=df, x='Churn')
plt.title("Distribuição de Churn")
plt.show()
